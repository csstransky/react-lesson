+ React is a JavaScript library created by Facebook
+ Went opensource in 2013
+ React Native: let's you make native mobile apps

+ React docs:
https://reactjs.org/docs/getting-started.html

+ Used by:
Twitter
Netflix
Facebook
Airbnb
Microsoft

+ Generating a React app:
$ npx create-react-app <project name>
$ cd <project name>
$ npm start

+ type "react.new" in a browser to go to a cool website that let's you make React stuff


+ <React.StrictMode> will warn you when you're not following the best practices for React
+ The first element sent to ReactDOM.render(..., ...) is what we want to create (usually an app.js script)
+ The second element tells you where that element is going to be injected
ReactDOM.render(
  React.createElement("h1", {style: {color: "magenta"}}, "Hello from the Children."),
  document.getElementById("root")
);


+ Use JSX (JS as XML) to avoid nesting
+ Let's you write tags directly into the .js files (looks a lot like HTML)
ReactDOM.render(
  <ul>
      <li>Monday</li>
      <li>Tuesday</li>
      <li>Wednesday</li>
  </ul>,
  document.getElementById("root")
);
+ NOTE: JSX does not actually run natively in HTML (of course)

+ Babel is what it's called to get JSX working behind the scenes
https://babeljs.io/repl
+ This is what the code above would look like in Babel (and why we use JSX instead):
ReactDOM.render( /*#__PURE__*/React.createElement("ul", null, /*#__PURE__*/React.createElement("li", null, "Monday"), /*#__PURE__*/React.createElement("li", null, "Tuesday"), /*#__PURE__*/React.createElement("li", null, "Wednesday")), document.getElementById("root"));


+ Components are created by creating a function, and they will return JSX
+ Essentially, if you create functions that return JSX, then you can use them all together in tandem:
function Header() {
    return (
        <header>
            <h1>Cristian's Place</h1>
        </header>
    )
}
function App() {
  return (
    <div className="App">
      <Header />
      <h2>Main</h2>
      <h3>Footer</h3>
    </div>
  );
}


+ Every React component has access to an Object called "props" (it can be any name, but it's the first
input variable to a component):
function Header(props) {
  return (
    <header>
      <h1>{props.name}'s Kitchen</h1>
    </header>
  );
}
function App() {
  return (
    <div className="App">
      <Header name="Cristian"/>
      <Main adjective="amazing"/>
      <Footer year={new Date().getFullYear()}/>
    </div>
  );
}

+ Because of how JSX is flexible, you can add quick styles and even iterate through a list by making sure
to use the curly braces, and returning JSX style HTML:
+ This will
function Main(props) {
  return (
    <section>
      <p>
        We serve the most {props.adjective} food around.
      </p>
        <ul style={{ textAlign: "left" }}>
            {props.dishes.map(dish => <li>{dish}</li>)}
        </ul>
    </section>
  );
}


+ Whenever rendering an Array using something like ".map" it's best practice to include a "key" in the <li> element
+ You *could* just add an index, but it's actually better to iterate over a list of Objects
(instead of just Strings), and use something like "dishes.id" and "dishes.title" instead
const dishes = [
  "Macaroni and Cheese",
  "Salmon",
  "Tofu with Vegetables"
];
const dishObjects = dishes.map((dish, ii) => ({id: ii, title: dish}));

function App() {
  return (
    <div className="App">
      <Header name="Horacio" />
      <Main adjective="amazing" dishes={dishObjects} />
      <Footer year={new Date().getFullYear()} />
    </div>
  );
}

function Main(props) {
  return (
    <section>
      <p>
        We serve the most {props.adjective} food around.
      </p>
      <ul style={{ textAlign: "left" }}>
        {props.dishes.map((dish) => (
          <li key={dish.id}>{dish.title}</li>
        ))}
      </ul>
    </section>
  );
}



+ You can import images through either a URL or locally in the "src" folder
+ Small note, you can't have images anywhere outside of the src folder for it to properly import
import friends from "./friends.jpg"
<img src={friends} height={200} alt="Friends Lego Boxset"/>
+ Important thing to note, for best practice, you need to include an "alt" tag for the description of
the image to help out people using text-to-speech apps or other CLI apps that make life easier for them


+ Small thing to note, multiple React components in the ReactDOM.render must be wrapped around something
in order to work.
+ You *could* use a <div>, but it adds unnecessary clutter to the DOM elements
+ Instead you can use <React.Fragment> to wrap multie React apps, and the best part is that it doesn't
add anything to the DOM elements
ReactDOM.render(
    <React.Fragment>
        <App /><AppTwo />
    </React.Fragment>, document.getElementById("root"));

+ Even cooler, there's an even easier syntactic sugar that can be used instead:
ReactDOM.render(
    <>
        <App /><AppTwo />
    </>, document.getElementById("root"));

+ Fragments can actually be used in the other parts of JSX as well, so don't be afraid to do something like
this:
function App() {
  return (
    <>
      <Header name="Horacio" />
      <Main adjective="amazing" dishes={dishObjects} />
      <Footer year={new Date().getFullYear()} />
    </>
  );
}


+ You can use conditional logic no problem with JS:
// index.js
ReactDOM.render(<App authorization={false}/>, document.getElementById("root"));

// App.js
function App(props) {
  return (
    <>
      {props.authorization ? <SecretComponent/> : <RegularComponent/>}
    </>
  )
}

+ Quick note, array deconstruction is when you give variables to specific array values:
const [mostImportantItem,,lamplol] = ["boots", "tent", "headlamp"];
console.log(mostImportantItem, lamplol);
+ Array deconstruction can be used for properties of a DOM too:
function App({authorized}) {
  console.log(authorized);
  return (
    <>
      {authorized ? (
        <SecretComponent />
      ) : (
        <RegularComponent />
      )}
    </>
  );
}

